WEBVTT
Kind: captions
Language: pt-BR

00:00:00.407 --> 00:00:04.285
O que temos aqui funciona,
mas, quando precisamos de uma lista,

00:00:04.318 --> 00:00:06.772
os itens ficarão em um array.

00:00:06.805 --> 00:00:09.469
Em vez de escrever
elementos filhos um a um,

00:00:09.502 --> 00:00:11.564
o React fornece
um array de elementos

00:00:11.597 --> 00:00:13.213
a serem usados como filhos.

00:00:13.246 --> 00:00:16.669
Isso facilita o trabalho
com arrays de dados existentes.

00:00:16.702 --> 00:00:20.493
Imagine que temos
um array de pessoas

00:00:20.526 --> 00:00:24.693
do qual desejamos gerar
dinamicamente os itens da lista.

00:00:24.726 --> 00:00:27.747
Poderíamos mapear
o array people

00:00:27.780 --> 00:00:32.052
e, para cada pessoa,
geraríamos um item de lista.

00:00:32.085 --> 00:00:36.107
Em vez de codificarmos o nome,
usaríamos person.name

00:00:36.140 --> 00:00:37.885
e obteríamos o mesmo resultado.

00:00:37.918 --> 00:00:42.568
Eu gosto de usar o JavaScript
para gerar esses elementos,

00:00:42.601 --> 00:00:45.528
porque não preciso de nenhuma
sintaxe especial

00:00:45.561 --> 00:00:47.056
para mapear o array.

00:00:47.089 --> 00:00:49.673
Em vez disso,
eu usei array.map.

00:00:49.706 --> 00:00:52.029
Eu não precisei
de uma linguagem modelo,

00:00:52.062 --> 00:00:56.253
que me desse uma repetição,
um mapeamento ou uma sintaxe

00:00:56.286 --> 00:00:58.116
para realizar o loop no array.

00:00:58.149 --> 00:01:00.765
Só precisei usar o JavaScript,
que já conheço.

00:01:00.798 --> 00:01:04.476
Outra coisa interessante
é que este objeto person

00:01:04.509 --> 00:01:06.075
já estava em escopo.

00:01:06.108 --> 00:01:08.462
Eu não precisei
de uma linguagem modelo

00:01:08.495 --> 00:01:10.533
para fornecer
o conceito de escopo.

00:01:10.566 --> 00:01:14.782
Apenas usei o objeto person
no escopo da função JavaScript.

00:01:14.815 --> 00:01:16.741
Não há nenhuma novidade aqui.

00:01:16.774 --> 00:01:20.197
Perceba que,
ao usar um array como filho,

00:01:20.230 --> 00:01:24.182
o React reclamará
se não houver uma chave.

00:01:24.215 --> 00:01:26.706
Se observarmos
o console no navegador,

00:01:26.739 --> 00:01:28.185
vemos um aviso.

00:01:28.218 --> 00:01:30.520
"Cada filho em um array
ou iterador

00:01:30.553 --> 00:01:32.577
deve ter
uma propriedade-chave.

00:01:32.610 --> 00:01:35.273
Confira a chamada de nível superior
usando &lt;ol&gt;."

00:01:35.306 --> 00:01:36.545
O que isso significa?

00:01:36.578 --> 00:01:39.601
Ao adicionarmos
className ao div,

00:01:39.634 --> 00:01:43.888
o segundo argumento apresenta
as propriedades do componente.

00:01:43.921 --> 00:01:46.953
Vamos atribuir
uma propriedade-chave única ao item,

00:01:46.986 --> 00:01:50.194
algo que seja único
para cada um dos objetos.

00:01:50.227 --> 00:01:52.379
Nesse caso,
o nome funcionaria,

00:01:52.412 --> 00:01:54.921
pois isso é único
para cada um dos objetos.

00:01:54.954 --> 00:01:57.689
Perceba
que o aviso desapareceu.

00:01:57.722 --> 00:02:02.081
Não nos aprofundaremos
na propriedade-chave nesta aula,

00:02:02.114 --> 00:02:05.450
mas saiba que se estiver
mapeando um array com o React

00:02:05.483 --> 00:02:08.248
e estiver criando elementos
para cada item do array,

00:02:08.281 --> 00:02:10.661
cada elemento precisará
de uma chave única.

