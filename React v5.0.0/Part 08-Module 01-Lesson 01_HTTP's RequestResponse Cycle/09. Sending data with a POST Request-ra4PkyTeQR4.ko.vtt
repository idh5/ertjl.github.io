WEBVTT
Kind: captions
Language: ko

00:00:00.180 --> 00:00:02.670
지금까지 우리는 GET 메소드를 사용하여

00:00:02.670 --> 00:00:05.650
서버에서 데이터를 요청했습니다

00:00:05.650 --> 00:00:07.890
하지만, 우리는 서버에게

00:00:07.890 --> 00:00:10.680
데이터를 전송하거나 사진을

00:00:10.680 --> 00:00:13.060
업로드 하고싶을 때가 있습니다

00:00:13.060 --> 00:00:15.150
이는 앞서 말했듯이

00:00:15.150 --> 00:00:16.680
POST 메소드가 존재하는 이유입니다

00:00:16.680 --> 00:00:19.710
POST 메소드로 요청문에서도

00:00:19.710 --> 00:00:21.780
응답문과 마찬가지로 데이터를

00:00:21.780 --> 00:00:25.680
추가해서 보낼 수 있습니다

00:00:25.680 --> 00:00:27.780
실제로 백엔드 개발자가 서버에서

00:00:27.780 --> 00:00:30.930
데이터를 받은 후 어떻게 처리하는 지는

00:00:30.930 --> 00:00:33.120
이번 강좌에서 다루지는 않습니다

00:00:33.120 --> 00:00:35.820
하지만 확실한 것은 POST 메소드는

00:00:35.820 --> 00:00:39.030
GET 메소드와 달리 브라우저나 프록시에 따라

00:00:39.030 --> 00:00:40.440
다르게 처리됩니다

00:00:40.440 --> 00:00:42.270
이런 화면을 본적 있으세요?

00:00:42.270 --> 00:00:44.430
이는 여러분이 보고 있는 화면이

00:00:44.430 --> 00:00:47.880
POST 메소드의 결과일 때 나타납니다

00:00:47.880 --> 00:00:50.310
이런 화면을 새로고침하려고 하면

00:00:50.310 --> 00:00:53.490
이 새 요청에 대한 프롬포트를 띄우게 됩니다

00:00:53.490 --> 00:00:56.730
그 이유는 POST 메소드는 GET과 달리
내용에 따라 다른 결과물을

00:00:56.730 --> 00:01:00.240
사용자에게 줄 수 있으므로

00:01:00.240 --> 00:01:01.380
이를 반복하게 되면 문제가 생기기 때문입니다

00:01:01.380 --> 00:01:03.240
이런 문제를 막기위해서

00:01:03.240 --> 00:01:04.890
백엔드 개발자들은 결과물을 바로 브라우저로

00:01:04.890 --> 00:01:08.760
전달하기 보다는 결과 페이지로

00:01:08.760 --> 00:01:11.190
redirect하는 것을 선호합니다

00:01:11.190 --> 00:01:14.490
유저 입장에서는 차이가 없지만

00:01:14.490 --> 00:01:17.390
이런 문제는 회피되게 되는 것입니다

