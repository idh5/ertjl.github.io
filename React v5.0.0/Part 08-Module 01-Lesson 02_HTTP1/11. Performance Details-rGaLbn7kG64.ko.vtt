WEBVTT
Kind: captions
Language: ko

00:00:00.804 --> 00:00:02.220
하지만 우리는 네트워크 아키텍쳐의 성질과

00:00:02.220 --> 00:00:05.990
싸워야 합니다

00:00:05.990 --> 00:00:08.340
예로, 주소창에 입력을 한 뒤

00:00:08.340 --> 00:00:10.140
페이지가 뜰 때까지 걸리는 시간의 절반은

00:00:10.140 --> 00:00:13.840
단순히 기다리는 시간입니다

00:00:13.840 --> 00:00:18.300
이를 보통 TTFB
time to first byte 라고 부르는데

00:00:18.300 --> 00:00:20.910
만약 웹사이트 추가 자원을 사용하려고 하면

00:00:20.910 --> 00:00:23.820
첫 요청이 완료되기 까지

00:00:23.820 --> 00:00:26.060
다음 요청이 기다려야 합니다

00:00:26.060 --> 00:00:28.890
이는 다른 자원들이 효율적으로

00:00:28.890 --> 00:00:31.320
사용되지 못하는 시간이 존재한다는 뜻입니다

00:00:31.320 --> 00:00:34.050
이 문제를 
head-of-line blocking이라 부릅니다

00:00:34.050 --> 00:00:36.570
예제를 보면서 
head-of-line blocking이 뭔지 살펴봅시다

00:00:36.570 --> 00:00:38.700
또한 이것이 얼마나 UX에 영향을 
주는지 알아 봅시다~

00:00:38.700 --> 00:00:40.260
[음악]

00:00:40.260 --> 00:00:43.020
HTTP를 사용하면 연결은 
마치 큐와 같이 동작합니다

00:00:43.020 --> 00:00:44.850
처음 요청이 처리되는 동안

00:00:44.850 --> 00:00:47.940
다른 요청들은 기다려야합니다

00:00:47.940 --> 00:00:50.360
여기서 많은 시간이 낭비됩니다

00:00:50.360 --> 00:00:51.700
중간 사이즈 커피 한 잔이요

00:00:51.700 --> 00:00:52.200
고맙습니다

00:00:52.200 --> 00:00:54.360
안녕히가세요

00:00:54.360 --> 00:00:55.744
지금 주문 가능한가요?

00:00:55.744 --> 00:00:56.910
네 뭐 드시겠어요?

00:00:56.910 --> 00:00:57.660
좋습니다

00:00:57.660 --> 00:00:58.610
저는 벤티 사이즈에

00:00:58.610 --> 00:01:02.067
미지근한 반은 그냥 우유
1/4은 저지방 우유 1/4은 무지방 우유

00:01:02.067 --> 00:01:03.900
샷을 네 개 추가할 건데, 한 잔 반은
디 카페인으로 두 잔 반은

00:01:03.900 --> 00:01:07.296
일반 샷으로 해주시고,
거품 없는 라떼로 해주시고

00:01:07.296 --> 00:01:09.170
크림을 추가해주세요 또
스플렌다 두 팩과 설탕을

00:01:09.170 --> 00:01:11.400
추가해주시고 바닐라 시럽과

00:01:11.400 --> 00:01:12.150
시나몬을 추가해주세요

00:01:12.150 --> 00:01:15.150
빨리 부탁해요~

00:01:15.150 --> 00:01:16.630
네..

00:01:16.630 --> 00:01:17.130
어..

00:01:17.130 --> 00:01:17.630
음..

00:01:17.630 --> 00:01:20.124
알겠습니다

00:01:20.124 --> 00:01:22.290
Richard의 주문이 준비되는 동안

00:01:22.290 --> 00:01:24.780
다른 손님들은 간단한 주문이라도

00:01:24.780 --> 00:01:28.170
한참 기다려야 합니다

00:01:28.170 --> 00:01:32.070
head-of-line blocking 문제를 위해

00:01:32.070 --> 00:01:33.870
브라우저는 최대 6개의 연결을

00:01:33.870 --> 00:01:36.680
추가해줍니다

00:01:36.680 --> 00:01:38.190
이 경우에는 예를 들면

00:01:38.190 --> 00:01:40.230
추가 바리스타를 고용하는 것이죠

00:01:40.230 --> 00:01:42.750
다른 연결이 그들의 응답을 기다리는 동안

00:01:42.750 --> 00:01:45.700
다른 요청이 서버에 보내지고

00:01:45.700 --> 00:01:46.960
처리되게 됩니다

00:01:46.960 --> 00:01:48.630
물론 이 새로운 바리스타를 고용하는 작업에

00:01:48.630 --> 00:01:50.070
시간과 돈이 소요됩니다

00:01:50.070 --> 00:01:52.590
브라우저에서 이 모든 연결에 대해

00:01:52.590 --> 00:01:55.870
TCP handshake가 필요하기 때문에
비용이 크게 듭니다.

00:01:55.870 --> 00:01:57.990
이 여섯개의 병렬적인 연결은

00:01:57.990 --> 00:02:01.407
하지만 여전히 임시방편일 뿐입니다.

00:02:01.407 --> 00:02:03.240
여러분의 페이지가 많은 리소스를

00:02:03.240 --> 00:02:05.850
포함하고 있다면 문제는 해결되지 않습니다

00:02:05.850 --> 00:02:08.600
그냥 캐셔를 처다보고 있어야하죠

00:02:08.600 --> 00:02:10.699
head-of-line blocking은
커다란 병목입니다

00:02:10.699 --> 00:02:12.200
웹사이트의 성능을 저하시킵니다

00:02:12.200 --> 00:02:14.910
브라우저가 연결을 6개까지 늘려서

00:02:14.910 --> 00:02:16.980
해결하려 하지만 완벽하진 않습니다

00:02:16.980 --> 00:02:19.770
HTTP/2에서 어떻게 이 문제를
해결하는 지

00:02:19.770 --> 00:02:21.940
나중에 살펴봅시다

