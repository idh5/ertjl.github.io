WEBVTT
Kind: captions
Language: ko

00:00:00.500 --> 00:00:02.540
프로토콜을 사용하기 위해서

00:00:02.540 --> 00:00:06.380
메소드, 경로, 버전 순으로 요청문을
작성해야 하는것을

00:00:06.380 --> 00:00:07.880
기억하시나요?

00:00:07.880 --> 00:00:10.700
이 요청문은 HEAD 메소드를
사용합니다

00:00:10.763 --> 00:00:12.374
HEAD 메소드는 실제로

00:00:12.500 --> 00:00:14.780
파일을 받지않고 그 헤더값만을

00:00:14.780 --> 00:00:18.350
받아오는 메소드 입니다

00:00:18.350 --> 00:00:20.690
이는 응답문을 저장하기 위한

00:00:20.690 --> 00:00:24.770
충분한 공간이 있는지나 혹은
현재 페이지에 대한 캐시가

00:00:24.830 --> 00:00:26.660
최신인지를 확인합니다

00:00:26.660 --> 00:00:29.960
이를 사용하면 캐시에 있는

00:00:29.960 --> 00:00:33.830
페이지를 다시 다운로드 하지 
않아도 됩니다

00:00:33.830 --> 00:00:35.960
개발자 도구에 네트워크 탭을 보면

00:00:35.960 --> 00:00:38.390
실제 웹사이트 방문시에 HEAD 메소드는

00:00:38.390 --> 00:00:40.130
사용되지 않음을 볼 수 있는데

00:00:40.130 --> 00:00:42.830
HEAD 메소드의 문제는

00:00:42.830 --> 00:00:45.050
두 번의 요청을 해야하는 것에 있습니다

00:00:45.050 --> 00:00:48.410
HEAD 요청을 보낸 뒤 GET 메소드를

00:00:48.410 --> 00:00:49.580
다시 요청해야 하기 때문입니다

00:00:49.580 --> 00:00:52.550
하나의 요청-응답 쌍을 
라운드 트립이라고

00:00:52.550 --> 00:00:54.920
부르는데, 하나의 라운드 트립은
많은 시간이 소요됩니다

00:00:54.920 --> 00:00:58.280
요즘 웹사이트는 많은 
파일들을 가지고 있는데

00:00:58.280 --> 00:01:01.250
각각에 대해 전부 HEAD-GET 메소드를
순서대로 사용하게 되면

00:01:01.250 --> 00:01:03.050
오히려 사이트 로딩시간이

00:01:03.050 --> 00:01:05.180
길어지게 됩니다

00:01:05.180 --> 00:01:08.510
후에 이 시간을 줄이는 방법에 대해

00:01:08.510 --> 00:01:11.030
살펴볼 것입니다 하지만

00:01:11.030 --> 00:01:14.120
지금은 사이트에 접속할 때

00:01:14.120 --> 00:01:16.520
가능한 적은 수의 라운드 트립이

00:01:16.520 --> 00:01:20.150
소요될수록 좋다는 사실만을 기억하세요

00:01:20.150 --> 00:01:22.640
마지막 메소드는 OPTIONS 입니다

00:01:22.640 --> 00:01:25.310
OPTIONS는 서버가 지원하는 메소드의

00:01:25.310 --> 00:01:28.500
목록을 출력해줍니다 하지만 모든 서버가

00:01:28.500 --> 00:01:30.050
이 메소드를 지원하지는 않습니다

00:01:30.050 --> 00:01:32.450
필요없어 보일 수도 있지만

00:01:32.450 --> 00:01:34.981
강의 후반부에서 아주 중요하게 사용되는

00:01:34.981 --> 00:01:37.701
메소드입니다

