WEBVTT
Kind: captions
Language: zh-CN

00:00:00.570 --> 00:00:03.310
我们手动编写了直接与互联网互动的请求

00:00:03.310 --> 00:00:05.759
并在服务器发出响应时

00:00:05.759 --> 00:00:07.567
就收到了它

00:00:07.567 --> 00:00:09.150
感觉很酷 对不对

00:00:09.150 --> 00:00:11.820
就好像我们和发送的字节之间

00:00:11.820 --> 00:00:13.050
几乎没有软件

00:00:13.050 --> 00:00:15.030
但其中依然发生了很多

00:00:15.029 --> 00:00:17.339
我们无法直接看到的操作

00:00:17.339 --> 00:00:20.550
实际上这对整个请求响应流程的速度

00:00:20.550 --> 00:00:22.380
有很大的影响

00:00:22.379 --> 00:00:25.859
如果你对网络基础架构有点熟悉

00:00:25.859 --> 00:00:29.429
就可能知道 HTTP 并不是整个组成部分

00:00:29.429 --> 00:00:31.050
它只是协议

00:00:31.050 --> 00:00:32.969
为了了解整个架构

00:00:32.969 --> 00:00:38.070
我们将 HTTP 放在 TCP 上方 放在 IP 上方 放在以太网上方

00:00:38.070 --> 00:00:40.590
大部分情况是这样

00:00:40.590 --> 00:00:42.690
我们不需要理解每个层级

00:00:42.689 --> 00:00:45.479
但 TCP 对如何构建

00:00:45.479 --> 00:00:47.969
性能高效的请求

00:00:47.969 --> 00:00:50.729
有着尤为重要的影响

00:00:50.729 --> 00:00:52.739
这值得仔细研究

00:00:52.740 --> 00:00:55.770
互联网协议使我们能够与

00:00:55.770 --> 00:00:57.990
互联网上的其他机器通信

00:00:57.990 --> 00:01:00.480
而 TCP 使我们能够在这两台机器之间

00:01:00.479 --> 00:01:02.369
建立多个独立的数据流

00:01:02.369 --> 00:01:05.370
这些数据流通过端口号加以区分

00:01:05.370 --> 00:01:09.180
TCP 协议还确保所有文件包都不会丢失

00:01:09.180 --> 00:01:11.760
并且按照正确的顺序抵达

00:01:11.760 --> 00:01:15.510
所有这些都需要耗费时间和资源成本的防范措施

00:01:15.510 --> 00:01:18.140
开启新连接的代价尤其高昂

00:01:18.140 --> 00:01:21.780
因为 TCP 握手要确保两台机器

00:01:21.780 --> 00:01:24.629
都发现新创建的通信渠道

00:01:24.629 --> 00:01:28.589
这需要两次往返通信

00:01:28.590 --> 00:01:32.579
如果使用的是 HTTPS

00:01:32.579 --> 00:01:35.099
还需要执行额外的 TLS 握手

00:01:35.099 --> 00:01:38.489
如果你不熟悉 HTTPS 和 TLS 不用担心

00:01:38.489 --> 00:01:40.949
我们将在下节课讲解这两个概念

00:01:40.950 --> 00:01:43.859
完成所有这些操作后

00:01:43.859 --> 00:01:45.790
真正的 HTTP 协议才最终接手任务

00:01:45.790 --> 00:01:47.940
队头阻塞是一个严重的网站性能

00:01:47.939 --> 00:01:49.319
瓶颈问题

00:01:49.319 --> 00:01:51.989
浏览器建立六个并行连接会有所帮助

00:01:51.989 --> 00:01:53.849
但是并不理想

00:01:53.849 --> 00:01:56.309
稍后我们将了解 HTTP2

00:01:56.310 --> 00:01:58.460
如何解决队头阻塞问题

