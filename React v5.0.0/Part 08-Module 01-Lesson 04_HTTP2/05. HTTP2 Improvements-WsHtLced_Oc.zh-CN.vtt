WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:03.270
Richard 介绍了 HTTP/1 的一些缺点

00:00:03.270 --> 00:00:05.570
并提到 HTTP/2 能够避免这些缺点

00:00:05.570 --> 00:00:06.930
但是如何避免呢？

00:00:06.929 --> 00:00:08.629
请拿出纸和笔

00:00:08.630 --> 00:00:12.320
因为我将介绍 HTTP/2 的神奇之处了

00:00:12.320 --> 00:00:15.230
还记得普通人能够读懂

00:00:15.230 --> 00:00:16.070
请求和响应报头吗？

00:00:16.070 --> 00:00:17.179
肯定要处理这种问题

00:00:17.179 --> 00:00:20.629
这是改善 HTTP/2 性能的第一步

00:00:20.629 --> 00:00:23.089
有这些报头很方便

00:00:23.089 --> 00:00:26.899
但是纯文本形式的 HTTP/1 报头对任何人都没好处

00:00:26.899 --> 00:00:29.509
以文本的形式呈现浪费了宝贵的空间

00:00:29.510 --> 00:00:32.658
一个位就能搞定

00:00:32.658 --> 00:00:33.649
但是别担心

00:00:33.649 --> 00:00:36.049
Wireshark 或 DevTools 等工具依然使你能够

00:00:36.049 --> 00:00:39.409
查看报头 即使 HTTP/2 也如此

00:00:39.409 --> 00:00:41.750
HTTP/2 解决的另一个重大问题是

00:00:41.750 --> 00:00:43.429
队头阻塞

00:00:43.429 --> 00:00:46.429
它通过一种叫做多路复用的技巧来解决这一问题

00:00:46.429 --> 00:00:48.500
多路复用是个比较华丽的词

00:00:48.500 --> 00:00:50.509
表示将多个信号

00:00:50.509 --> 00:00:52.820
整合成一个新的信号

00:00:52.820 --> 00:00:57.170
对于 HTTP/2 我们现在有一个连接 而不是六个连接

00:00:57.170 --> 00:00:59.670
咋听起来像是一种可怕的退步

00:00:59.670 --> 00:01:02.060
但是我们使用单个连接的方式

00:01:02.060 --> 00:01:03.980
与 HTTP/1 不同

00:01:03.979 --> 00:01:06.829
在 HTTP/1 中称为专属连接的连接

00:01:06.829 --> 00:01:09.530
现在是信息流

00:01:09.530 --> 00:01:11.540
所有信息流共享一个连接

00:01:11.540 --> 00:01:13.490
这些信息流拆分为帧

00:01:13.489 --> 00:01:16.789
并在该单个连接上多路复用

00:01:16.790 --> 00:01:19.100
当一个信息流被阻塞时

00:01:19.099 --> 00:01:21.890
另一个信息流可以获取该连接

00:01:21.890 --> 00:01:23.500
并充分利用本来会成为闲置时间的时段

00:01:23.500 --> 00:01:25.400
队头阻塞问题解决了

00:01:25.400 --> 00:01:29.790
最后 HTTP/2 可以压缩报头数据

00:01:29.790 --> 00:01:31.850
对于 HTTP/2

00:01:31.849 --> 00:01:34.399
报头不仅通过 gzip 被压缩

00:01:34.400 --> 00:01:36.830
并且工程师设计出

00:01:36.829 --> 00:01:39.769
专门针对报头的特殊结构

00:01:39.769 --> 00:01:42.560
和 HTTP/2 多路复用功能的压缩算法

00:01:42.560 --> 00:01:45.710
所有信息流不仅共享连接

00:01:45.709 --> 00:01:46.909
并且共享压缩器

00:01:46.909 --> 00:01:49.759
意味着报头不用被发送两次

00:01:49.760 --> 00:01:52.730
因为压缩器能够识别报头之前被发送过

00:01:52.730 --> 00:01:55.130
所以会改为发送引用

00:01:55.129 --> 00:01:57.799
例如 Cookie 是非常长的报头

00:01:57.799 --> 00:02:00.079
因此 如果在这里插入

00:02:00.079 --> 00:02:02.689
和前面第三个请求一样的 Cookie

00:02:02.689 --> 00:02:05.239
而不是插入实际值 会有很大的优势

00:02:05.239 --> 00:02:08.388
我不会详细介绍该压缩算法的细节内容

00:02:08.389 --> 00:02:10.860
但是如果你想知道它的工作原理

00:02:10.860 --> 00:02:14.260
请参阅讲师注释中的课外资料

