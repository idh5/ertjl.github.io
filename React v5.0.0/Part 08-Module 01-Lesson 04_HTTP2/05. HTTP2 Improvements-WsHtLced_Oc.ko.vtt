WEBVTT
Kind: captions
Language: ko

00:00:00.500 --> 00:00:03.270
Richard가 여러분에게 HTTP/1의 
문제점을 보여주었고

00:00:03.270 --> 00:00:05.570
HTTP/2가 이들을 해결할 수 있다고
하였습니다

00:00:05.570 --> 00:00:06.930
그런데 어떻게 할까요?

00:00:06.930 --> 00:00:08.630
이제 여러분 연필을 꺼내세요

00:00:08.630 --> 00:00:12.320
왜냐하면 여러분에게 HTTP/2의
기적을 보여줄 것이기 때문이죠

00:00:12.320 --> 00:00:15.230
요청문과 응답문의 헤더가 읽기 쉬웠다는 사실을

00:00:15.230 --> 00:00:16.070
기억하시나요?

00:00:16.070 --> 00:00:17.180
이제 없어질 때가 됐습니다

00:00:17.180 --> 00:00:20.630
HTTP/2에서 성능 향상을 위한
첫 번째 단계입니다

00:00:20.630 --> 00:00:23.090
아무도 평문으로 적힌 헤더에서

00:00:23.090 --> 00:00:26.900
장점을 느끼지 못합니다

00:00:26.900 --> 00:00:29.510
우리는 하나의 비트로 대체하여도 될

00:00:29.510 --> 00:00:32.659
부분을 긴 문장으로 낭비하고 있습니다

00:00:32.659 --> 00:00:33.650
이제 걱정하지마세요

00:00:33.650 --> 00:00:36.050
개발자 도구나 Wireshark 같은 도구로

00:00:36.050 --> 00:00:39.410
HTTP/2에서도 헤더를 확인할 수 있습니다

00:00:39.410 --> 00:00:41.750
두 번째 큰 문제는

00:00:41.750 --> 00:00:43.430
head-of-line blocking 이였습니다

00:00:43.430 --> 00:00:46.430
이는 multiplexing으로 해결하였습니다

00:00:46.430 --> 00:00:48.500
이 multiplexing이라는 것은

00:00:48.500 --> 00:00:50.510
여러 신호를 하나의 새로운 신호로

00:00:50.510 --> 00:00:52.820
합치는 것을 말합니다

00:00:52.820 --> 00:00:57.170
HTTP/2를 사용하면 우리는 6개의 
연결 대신에 하나의 연결만을 사용합니다

00:00:57.170 --> 00:00:59.670
처음에는 왜그러는지 의문이 들 수도 있지만

00:00:59.670 --> 00:01:02.060
HTTP/2에서는 HTTP/1과 다르게

00:01:02.060 --> 00:01:03.980
이 연결을 사용합니다

00:01:03.980 --> 00:01:06.830
HTTP/1에서의 연결은

00:01:06.830 --> 00:01:09.530
이제 Stream이라고 불립니다

00:01:09.530 --> 00:01:11.540
그리고 모든 스트림은 하나의
연결을 공유합니다

00:01:11.540 --> 00:01:13.490
이 스트림들은 프레임들로
나누어지고

00:01:13.490 --> 00:01:16.790
이들은 하나의 연결에 
멀티플렉싱됩니다

00:01:16.790 --> 00:01:19.100
우리의 스트림이 막히면

00:01:19.100 --> 00:01:21.890
다른 스트림이 이 연결을 점유하고

00:01:21.890 --> 00:01:23.500
빈 시간없이 사용되게 됩니다

00:01:23.500 --> 00:01:25.400
이제 HOL 문제는 없습니다

00:01:25.400 --> 00:01:29.790
최근에 HTTP/2는 헤더 데이터가
압축되지 않는 것에 집중했습니다

00:01:29.790 --> 00:01:31.850
HTTP/2에서는 헤더는 압축될 뿐만

00:01:31.850 --> 00:01:34.400
아니라, 헤더 특유의 구조에 맞춘

00:01:34.400 --> 00:01:36.830
압축도구를 제공하고

00:01:36.830 --> 00:01:39.770
HTTP/2의 멀티플렉싱 특성에 따라

00:01:39.770 --> 00:01:42.560
모든 스트림들이 연결만 공유하는 것이

00:01:42.560 --> 00:01:45.710
아니라, 똑같은 압축도구를 공유하게

00:01:45.710 --> 00:01:46.910
됩니다

00:01:46.910 --> 00:01:49.760
이 말은 헤더들이 두 번 보내지지 않고

00:01:49.760 --> 00:01:52.730
압축도구(컴프레서)가 이 전에 보냈다는 것을
인지하게 되면

00:01:52.730 --> 00:01:55.130
그들의 참조만을 보냅니다

00:01:55.130 --> 00:01:57.800
예로 쿠키는 아주 긴 헤더인데

00:01:57.800 --> 00:02:00.080
실제 값을 헤더에 넣기 보다는

00:02:00.080 --> 00:02:02.690
세 요청전에 똑같은 값을 보냈다라는

00:02:02.690 --> 00:02:05.240
사실을 알려주면 아주 편리합니다

00:02:05.240 --> 00:02:08.389
이 알고리즘에 대해서 자세히 
살펴보지는 않겠습니다

00:02:08.389 --> 00:02:10.860
여러분이 관심이 있으시다면

00:02:10.860 --> 00:02:14.260
강사메모에 링크가 있습니다!

