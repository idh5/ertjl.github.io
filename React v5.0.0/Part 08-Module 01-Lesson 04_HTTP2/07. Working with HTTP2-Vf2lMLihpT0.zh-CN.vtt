WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:02.520
HTTP/2 带来了很多变化

00:00:02.520 --> 00:00:04.859
但是如何从 HTTP/1

00:00:04.860 --> 00:00:07.440
转换为强大的 HTTP/2 呢？

00:00:07.440 --> 00:00:09.690
如何以最佳方式

00:00:09.689 --> 00:00:12.419
满足所有用户的需求？

00:00:12.419 --> 00:00:15.810
随着 HTTP/2 中的队头阻塞消失了

00:00:15.810 --> 00:00:18.690
并且现在报头压缩请求代价很低

00:00:18.690 --> 00:00:21.600
因此没有必要

00:00:21.600 --> 00:00:23.250
合并 JavaScript 或 CSS 了

00:00:23.250 --> 00:00:25.410
实际上让情况变得更糟糕

00:00:25.410 --> 00:00:27.629
假设要更新一个缓存的文件

00:00:27.629 --> 00:00:29.640
如果你修正了 JavaScript 文件中的一个拼写错误

00:00:29.640 --> 00:00:32.158
例如缺少一个花括号

00:00:32.158 --> 00:00:35.549
则用户必须重新下载合并的整个 JavaScript

00:00:35.549 --> 00:00:38.729
而不是仅仅发生更改的片段

00:00:38.729 --> 00:00:40.890
如果每个 JavaScript 文件都分开来了

00:00:40.890 --> 00:00:44.700
则只需让这个文件的缓存变得无效

00:00:44.700 --> 00:00:46.830
另一个优势是发送的请求越多

00:00:46.829 --> 00:00:49.859
新的报头压缩法越高效

00:00:49.859 --> 00:00:53.888
发送的请求越多 重复利用的报头越多

00:00:53.889 --> 00:00:55.679
意味着有多个指向不同服务器的连接

00:00:55.679 --> 00:00:59.280
实际上对性能有负面影响

00:00:59.280 --> 00:01:02.969
但是 缩小和压缩 JavaScript CSS 及图片

00:01:02.969 --> 00:01:05.039
依然是很好的做法

00:01:05.040 --> 00:01:07.140
哪怕是一个字节都值得节省

00:01:07.140 --> 00:01:09.329
尤其是在发展中国家/地区

00:01:09.329 --> 00:01:11.159
节省字节就是节省费用

00:01:11.159 --> 00:01:14.129
此外 关于渲染性能的所有建议依然有效

00:01:14.129 --> 00:01:17.849
例如推迟 JavaScript 或内嵌样式

00:01:17.849 --> 00:01:20.759
花时间构建完善的

00:01:20.760 --> 00:01:22.740
客服支持服务也不例外

00:01:22.739 --> 00:01:26.489
最重要的是 HTTP/2 可以向后兼容

00:01:26.489 --> 00:01:30.839
所有支持 HTTP/2 的服务器都将支持 HTTP/1

00:01:30.840 --> 00:01:35.340
不支持 HTTP/2 的客户端将直接后退成支持 HTTP/1

00:01:35.340 --> 00:01:37.320
并且和之前一样运转

00:01:37.319 --> 00:01:39.929
而这些客户端越来越少

00:01:39.930 --> 00:01:42.930
因此不用担心使用 HTTP/2 有何问题

00:01:42.930 --> 00:01:47.850
2016 年初拍摄本视频时 71% 的网络流量

00:01:47.849 --> 00:01:49.719
支持 HTTP/2

00:01:49.719 --> 00:01:52.079
这一数字还会继续增长

00:01:52.079 --> 00:01:55.950
因此你完全可以针对 HTTP/2 优化网站

00:01:55.950 --> 00:01:59.420
而不用太关心 HTTP/1

